---
title: Auction and Scoring
description: Learn how AIP defines auction constraints and outcome guarantees, while operators implement their own auction and scoring logic.
---


AIP defines protocol-level constraints and guarantees for auctions, while operators implement their own auction mechanics and scoring algorithms. When a platform sends a `PlatformRequest`, the operator derives a `ContextRequest` and distributes it to Brand Agents. Operators define their own distribution mechanisms (e.g., category pools, publish/subscribe transport) and auction timing.

## 1. TL;DR

> AIP defines auction inputs, timing constraints, and outcome guarantees. Operators implement their own auction and scoring logic to select winning bids.

## 2. Why It Matters

AIP enables AI systems to monetize intent responsibly by defining:

- **Protocol-level constraints** that ensure fair competition
- **Timing guarantees** that respect platform latency budgets
- **Outcome guarantees** that ensure deterministic settlement

Operators implement auction and scoring logic that prioritizes relevance, quality, and economic value, creating recommendations that feel useful, aligned, and trustworthy.

This ensures:

- AI experiences remain user-centric
- Brands compete on merit and integrity
- Platforms gain a predictable monetization layer

## 3. Protocol-Level Auction Constraints

AIP defines constraints and guarantees for auctions, not the specific algorithms:

### **1. Input Requirements**
An AI platform submits a `PlatformRequest` (UCP format) describing the user's query or action. The request includes `latency_budget_ms` to specify the platform's timing requirements.

### **2. Distribution Requirements**
The Operator derives a `ContextRequest` (UCP-like format) and distributes it to Brand Agents. Operators define their own distribution mechanisms (category pools, transport methods, etc.).

### **3. Timing Constraints**
- The auction window is derived from the platform's `latency_budget_ms` field in the PlatformRequest
- Operators compute the available bid window by subtracting operator overhead from the platform's latency budget
- Brand Agents MUST submit bids within the computed window
- Late bids are rejected and do not participate in selection or settlement
- If no `latency_budget_ms` is provided, operators apply their own default fallback

### **4. Bid Collection**
Brand Agents submit signed `BidResponse` payloads with pricing, creative input, and relevance scores. Operators collect bids received within the auction window.

### **5. Outcome Guarantees**
The Operator MUST return a single `AuctionResult` (or `no_bid` when no responses arrive in time) and a `serve_token` back to the Platform. The protocol guarantees deterministic settlement based on the event ladder (CPA > CPC > CPX).

## 4. Scoring (Informational)

Operators implement their own scoring algorithms to evaluate bids. While AIP does not prescribe a specific scoring model, operators typically consider signals such as:

### **Value**
Economic strength of the bid relative to the current intent.

### **Relevance**
Alignment between the offer and the user's query, conversation, or task context.

### **Quality**
Trust, integrity, and historical performance signals from the Brand Agent's verified events.

Operators apply their own scoring logic consistently for all bids, producing deterministic outcomes. The highest-scoring offer (according to the operator's algorithm) becomes the result of the auction.

**Note**: AIP does not mandate how operators combine these signals or weight them. Each operator defines their own scoring methodology.

## 5. AuctionResult

The operator returns an `AuctionResult` containing the winning bid and format-specific creative:

```json
{
  "auction_id": "auc_981",
  "serve_token": "stk_abcxyz123",
  "winner": {
    "brand_agent_id": "ba_451",
    "preferred_unit": "CPA",
    "reserved_amount_cents": 500
  },
  "render": {
    "format": "weave",
    "weave_content": "[Ad] For startups needing higher limits and automated expense workflows. CRM built for growing teams, with AI-assisted workflows. Learn more: https://admesh.click/stk_abcxyz123"
  },
  "ttl_ms": 60000
}
```

For complete auction result schema, see: [Auction Result Schema](/schemas/auction-result)

## 6. Transparency and Verification

Every exchange in the auction cycle is logged as verifiable artifacts:

- signed `ContextRequest`
- signed `BidResponse`
- signed `AuctionResult`
- timestamps and nonces
- protocol version identifiers

## 7. Example Flow

User asks: **"Best AI note-taking tools."**

1. Platform sends `PlatformRequest` with `latency_budget_ms` to Operator.
2. Operator derives `ContextRequest` and distributes it to eligible Brand Agents using operator-defined mechanisms.
3. Brand Agents return bids within the computed auction window.
4. Operator applies its scoring algorithm to rank bids.
5. Platform receives a single `AuctionResult` with `serve_token`.
6. Exposure and click events connect cleanly to the same attribution chain via `serve_token`.

## 7. Protocol Guarantees

AIP ensures:

- **Timing compliance**: Bids received after the computed window are rejected
- **Deterministic settlement**: Event ladder (CPA > CPC > CPX) ensures one charge per `serve_token`
- **Complete verifiability**: All messages are signed and timestamped
- **Unified attribution**: `serve_token` links all events to the original auction
- **Operator autonomy**: Operators define their own auction and scoring logic within protocol constraints

## Summary

AIP defines protocol-level constraints for auctions—timing, inputs, and outcome guarantees—while operators implement their own auction mechanics and scoring algorithms. The protocol harmonizes how Platforms monetize intent, how Brand Agents compete, and how Operators deliver transparent, reproducible outcomes within their own implementation choices.
